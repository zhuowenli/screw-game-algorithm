<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>ä¸‰æ¶ˆæ¸¸æˆï¼ˆè‡ªåŠ¨è¡¥ç‚¹ + é…å¥—åœ†ç‚¹ï¼‰</title>
    <style>
        body {
            font-family: sans-serif;
            background: #f8f8f8;
            text-align: center;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(20, 30px);
            grid-template-rows: repeat(30, 30px);
            gap: 2px;
            margin: 20px auto;
            background: #ccc;
            width: fit-content;
            position: relative;
        }

        .plate {
            position: absolute;
            pointer-events: none;
            border-radius: 4px;
        }

        .dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            top: 1px;
            left: 1px;
            cursor: pointer;
            box-shadow: 0 0 2px #555;
            z-index: 10;
        }

        .dot.blocked {
            cursor: not-allowed;
            pointer-events: none;
        }

        #line-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1500;
        }

        .line {
            stroke: #666;
            stroke-width: 2;
        }

        .lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            color: #fff;
            text-shadow: 0 0 2px #000;
        }

        .cell {
            width: 30px;
            height: 30px;
            background: #eee;
            position: relative;
        }



        #boxes {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px auto;
        }

        .box {
            width: 120px;
            height: 60px;
            border-radius: 15px;
            background-color: white;
            border: 3px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: relative;
        }

        .box.enabled {
            cursor: default;
            justify-content: space-around;
        }

        .box .slot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: white;
            box-shadow: inset 0 0 2px #999;
        }

        .box .hint {
            position: absolute;
            color: #999;
            font-size: 14px;
            pointer-events: none;
        }

        #temp-slots {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px auto;
        }

        .temp-slot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px dashed #aaa;
            background: #fff;
            box-shadow: inset 0 0 2px #999;
            position: relative;
        }

        .temp-slot .dot {
            position: absolute;
            top: 1px;
            left: 1px;
        }

        #info-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 200px;
            text-align: left;
            background: #ccc;
            border: 1px solid #aaa;
            padding: 10px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.1);
            font-size: 14px;
        }

        #info-panel span {
            font-weight: bold;
            margin-left: 5px;
        }

        #color-stats div {
            margin-top: 2px;
        }

        #message {
            margin-top: 20px;
            font-size: 1.2em;
            color: red;
        }
    </style>
</head>

<body>
    <h1>ä¸‰æ¶ˆæ¸¸æˆï¼ˆè‡ªåŠ¨è¡¥ç‚¹ + é…å¥—åœ†ç‚¹ï¼‰</h1>

    <div id="boxes">
        <div class="box" data-enabled="true"></div>
        <div class="box" data-enabled="true"></div>
        <div class="box" data-enabled="false">
            <div class="hint">ç‚¹å‡»å¼€å¯</div>
        </div>
        <div class="box" data-enabled="false">
            <div class="hint">ç‚¹å‡»å¼€å¯</div>
        </div>
    </div>

    <div id="temp-slots">
        <div class="temp-slot"></div>
        <div class="temp-slot"></div>
        <div class="temp-slot"></div>
        <div class="temp-slot"></div>
        <div class="temp-slot"></div>
    </div>

    <div id="info-panel">
        <div>å…³å¡æ€»èºä¸æ•°:<span id="total-count"></span></div>
        <div>å·²æ¶ˆé™¤èºä¸æ•°:<span id="eliminated-count">0</span></div>
        <div>æœªæ¶ˆé™¤èºä¸æ•°:<span id="remaining-count">0</span></div>
        <div>åœºä¸Šèºä¸æ•°:<span id="onboard-count">0</span></div>
        <div>é˜Ÿåˆ—ä¸­èºä¸æ•°:<span id="queue-count">0</span></div>
        <div>é¢œè‰²ç§ç±»:<span id="color-count">0</span></div>
        <div id="color-stats"></div>
    </div>

    <div id="game-board"><svg id="line-layer"></svg></div>

    <div id="message"></div>

    <script>
        const COLORS = ["red", "blue", "green", "yellow", "purple", "orange", "pink"];
        const COLOR_NAMES = {
            red: "çº¢è‰²",
            blue: "è“è‰²",
            green: "ç»¿è‰²",
            yellow: "é»„è‰²",
            purple: "ç´«è‰²",
            orange: "æ©™è‰²",
            pink: "ç²‰è‰²"
        };
        const ROWS = 30;
        const COLS = 20;
        const MAX_ACTIVATED_CELLS = 200;
        const TOTAL_SCREWS = 90;
        const MAX_VISIBLE_PLATES = 4; // åŒæ—¶æœ€å¤šæ˜¾ç¤ºçš„æ¿å—æ•°é‡
        // è®°å½•æœ€è¿‘ä¸€æ¬¡æ‹”å‡ºèºä¸çš„æ ¼å­
        let lastRemovedCell = null;

        // èºä¸ç”Ÿæˆç®—æ³•ï¼šæ¯3ä¸ªèºä¸éšæœºç”Ÿæˆä¸€ä¸ªé¢œè‰²ï¼Œç›´åˆ°ç”ŸæˆTOTAL_SCREWSä¸ªèºä¸
        const COLOR_TOTALS = Array(TOTAL_SCREWS)
            .fill(0)
            .map((_, i) => i)
            .reduce((acc, i) => {
                if (i % 3 === 0) {
                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    acc[color] = acc[color] ? acc[color] + 3 : 3;
                }
                return acc;
            }, {});
        const COLOR_BOX_TOTALS = Object.fromEntries(
            Object.entries(COLOR_TOTALS).map(([c, n]) => [c, n / 3])
        );

        const colorPool = {
            ...COLOR_TOTALS
        };
        const boxPool = {
            ...COLOR_BOX_TOTALS
        };
        const colorOnField = Object.fromEntries(COLORS.map(c => [c, 0]));
        let eliminated = 0;

        const board = document.getElementById("game-board");
        const lineLayer = document.getElementById("line-layer");
        let lockConnections = [];
        const screwMap = {};
        let nextScrewId = 0;
        const boxes = document.querySelectorAll(".box");
        const tempSlots = document.querySelectorAll(".temp-slot");
        const message = document.getElementById("message");
        const totalCountEl = document.getElementById("total-count");
        const eliminatedCountEl = document.getElementById("eliminated-count");
        const remainingCountEl = document.getElementById("remaining-count");
        const onboardCountEl = document.getElementById("onboard-count");
        const queueCountEl = document.getElementById("queue-count");
        const colorCountEl = document.getElementById("color-count");
        const colorStats = document.getElementById("color-stats");

        const cellMap = [];
        let activeCells = [];
        let usedBoxColors = new Set();
        let plates = [];
        let nextPlateIndex = 0; // ä¸‹ä¸€ä¸ªéœ€è¦æ˜¾ç¤ºçš„æ¿å—ç´¢å¼•
        let activePlates = [];
        // æ§åˆ¶æ¿å—ä¸èºä¸çš„å±‚çº§ï¼Œæ¯å±‚ä¹‹é—´ç›¸å·® 10ï¼Œæ–¹ä¾¿è°ƒè¯•
        let nextPlateZ = 1000; // è®°å½•ä¸‹ä¸€ä¸ªæ¿å—çš„ zIndexï¼Œä»å¤§åˆ°å°ç”Ÿæˆï¼Œç¡®ä¿æ–°æ¿å—åœ¨ä¸‹å±‚

        function createGrid() {
            for (let row = 0; row < ROWS; row++) {
                cellMap[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement("div");
                    cell.className = "cell";
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                    cellMap[row][col] = cell;
                }
            }
        }

        function activateCells() {
            const allCells = [];
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    allCells.push(cellMap[row][col]);
                }
            }

            activeCells = [];
            const used = new Set();
            while (activeCells.length < MAX_ACTIVATED_CELLS) {
                const index = Math.floor(Math.random() * allCells.length);
                const cell = allCells[index];
                const key = `${cell.dataset.row}-${cell.dataset.col}`;
                if (!used.has(key)) {
                    used.add(key);
                    cell.style.backgroundColor = "#fff8dc";
                    activeCells.push(cell);
                }
            }
        }

        // éšæœºç”Ÿæˆæ‰€æœ‰æ¿å—åŠå…¶èºä¸ä½ç½®ï¼Œæ¯å—æ¿ä¸Šéšæœº 1-9 é¢—èºä¸
        function generatePlates() {
            let remaining = TOTAL_SCREWS;
            let id = 0;
            const tempPool = {
                ...COLOR_TOTALS
            };
            while (remaining > 0) {
                const screwCount = Math.min(remaining, Math.floor(Math.random() * 9) + 1);
                const width = Math.floor(Math.random() * 6) + 3;
                const height = Math.floor(Math.random() * 6) + 3;
                const row = Math.floor(Math.random() * (ROWS - height));
                const col = Math.floor(Math.random() * (COLS - width));
                const cells = [];
                for (let r = row; r < row + height; r++) {
                    for (let c = col; c < col + width; c++) {
                        cells.push({
                            row: r,
                            col: c
                        });
                    }
                }
                for (let i = cells.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cells[i], cells[j]] = [cells[j], cells[i]];
                }
                const plateCells = cells.slice(0, screwCount);
                const screws = [];
                for (const pos of plateCells) {
                    const colorsCanUse = COLORS.filter(c => tempPool[c] > 0);
                    const color = colorsCanUse[Math.floor(Math.random() * colorsCanUse.length)];
                    screws.push({
                        row: pos.row,
                        col: pos.col,
                        color,
                        cell: null,
                        dot: null,
                        locked: false,
                        controller: null,
                        controls: null,
                        overlay: null,
                        plateId: id,
                        id: nextScrewId++
                    });
                    screwMap[screws[screws.length - 1].id] = screws[screws.length - 1];
                    tempPool[color]--;
                    remaining--;
                }
                plates.push({
                    id: id++,
                    row,
                    col,
                    width,
                    height,
                    color: `rgba(${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},0.6)`,
                    screws,
                    zIndex: nextPlateZ
                });
                nextPlateZ -= 10;
            }
        }

        function spawnDot(screw, cell) {
            const dot = document.createElement("div");
            dot.className = "dot";
            dot.style.backgroundColor = screw.color;
            dot.dataset.color = screw.color;
            dot.dataset.sid = screw.id;
            dot.dataset.blocked = "false";
            dot.addEventListener("click", () => handleDotClick(dot));
            cell.appendChild(dot);
            colorPool[screw.color]--;
            colorOnField[screw.color]++;
            return dot;
        }

        function removeDot(dot) {
            const color = dot.dataset.color;
            const cell = dot.parentElement;
            const screw = screwMap[dot.dataset.sid];
            if (screw) screw.dot = null;
            lockConnections.slice().forEach(conn => {
                if (conn.controller.id === screw.id || conn.locked.id === screw.id) removeConnection(conn);
            });
            dot.remove();
            colorOnField[color]--;
            eliminated++;
            if (cell) checkPlateRemoval(cell);
        }

        // åœ¨åœºæ™¯ä¸­ç”Ÿæˆä¸€ä¸ªæ¿å—åŠå…¶èºä¸
        function spawnPlate(plate) {
            const overlay = document.createElement('div');
            overlay.className = 'plate';
            overlay.style.backgroundColor = plate.color;
            overlay.style.left = plate.col * 32 + 'px';
            overlay.style.top = plate.row * 32 + 'px';
            overlay.style.width = plate.width * 32 - 2 + 'px';
            overlay.style.height = plate.height * 32 - 2 + 'px';
            overlay.style.zIndex = plate.zIndex;
            board.appendChild(overlay);
            const used = new Set();
            let placed = 0;
            for (const screw of plate.screws) {
                let cell = cellMap[screw.row][screw.col];
                if (cell.querySelector('.dot')) {
                    const candidates = [];
                    for (let r = plate.row; r < plate.row + plate.height; r++) {
                        for (let c = plate.col; c < plate.col + plate.width; c++) {
                            const candidate = cellMap[r][c];
                            const key = `${r}-${c}`;
                            if (!candidate.querySelector('.dot') && !used.has(key)) {
                                candidates.push(candidate);
                            }
                        }
                    }
                    if (candidates.length === 0) continue;
                    cell = candidates[Math.floor(Math.random() * candidates.length)];
                }
                used.add(`${cell.dataset.row}-${cell.dataset.col}`);
                screw.cell = cell;
                cell.dataset.plateId = plate.id;
                const dot = spawnDot(screw, cell);
                dot.style.zIndex = plate.zIndex + 1;
                screw.dot = dot;
                placed++;
            }
            if (placed === 0) {
                overlay.remove();
                return false;
            }
            plate.overlay = overlay;
            activePlates.push(plate);
            updateDotBlockStates();
            return true;
        }

        function removePlate(plate) {
            plate.overlay && plate.overlay.remove();
            for (const screw of plate.screws) {
                if (screw.dot) screw.dot.remove();
                lockConnections.slice().forEach(conn => {
                    if (conn.controller === screw || conn.locked === screw) removeConnection(conn);
                });
                if (screw.cell) screw.cell.dataset.plateId = '';
            }
            activePlates = activePlates.filter(p => p !== plate);
            updateDotBlockStates();
        }

        // æ ¹æ®å½“å‰æ¿å—å±‚çº§ï¼Œæ§åˆ¶èºä¸çš„å¯ç‚¹å‡»çŠ¶æ€
        function updateDotBlockStates() {
            const topMap = {};
            // è®¡ç®—æ¯ä¸ªæ ¼å­ä¸Šæ–¹è¦†ç›–çš„æœ€é«˜æ¿å—
            const sorted = [...activePlates].sort((a, b) => a.zIndex - b.zIndex);
            for (const plate of sorted) {
                for (let r = plate.row; r < plate.row + plate.height; r++) {
                    for (let c = plate.col; c < plate.col + plate.width; c++) {
                        const key = `${r}-${c}`;
                        topMap[key] = plate;
                    }
                }
            }

            // è®¾ç½®èºä¸æ˜¯å¦å¯ç‚¹å‡»
            for (const plate of activePlates) {
                for (const screw of plate.screws) {
                    if (!screw.dot || !screw.cell) continue;
                    const key = `${screw.cell.dataset.row}-${screw.cell.dataset.col}`;
                    const top = topMap[key];
                    const blocked = !(top && top.id === plate.id) || screw.locked;
                    screw.dot.dataset.blocked = blocked ? 'true' : 'false';
                    screw.dot.classList.toggle('blocked', blocked);
                }
            }
        }

        function getDotCenter(dot) {
            const br = board.getBoundingClientRect();
            const dr = dot.getBoundingClientRect();
            return {
                x: dr.left - br.left + dr.width / 2,
                y: dr.top - br.top + dr.height / 2
            };
        }

        function drawLine(fromDot, toDot) {
            const p1 = getDotCenter(fromDot);
            const p2 = getDotCenter(toDot);
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", p1.x);
            line.setAttribute("y1", p1.y);
            line.setAttribute("x2", p2.x);
            line.setAttribute("y2", p2.y);
            line.classList.add("line");
            lineLayer.appendChild(line);
            return line;
        }

        function removeConnection(conn) {
            conn.line && conn.line.remove();
            if (conn.locked.overlay) {
                conn.locked.overlay.remove();
                conn.locked.overlay = null;
            }
            if (conn.locked.dot) {
                conn.locked.dot.dataset.blocked = 'false';
                conn.locked.dot.classList.remove('blocked');
            }
            conn.locked.locked = false;
            conn.locked.controller = null;
            conn.controller.controls = null;
            lockConnections = lockConnections.filter(c => c !== conn);
        }

        function applyLock(controller, locked) {
            controller.controls = locked;
            locked.controller = controller;
            locked.locked = true;
            if (locked.dot) {
                locked.dot.dataset.blocked = 'true';
                locked.dot.classList.add('blocked');
                const ov = document.createElement('div');
                ov.className = 'lock-overlay';
                ov.textContent = 'ğŸ”’';
                locked.dot.appendChild(ov);
                locked.overlay = ov;
            }
            if (controller.dot && locked.dot) {
                const line = drawLine(controller.dot, locked.dot);
                lockConnections.push({
                    controller,
                    locked,
                    line
                });
            }
        }

        function canControl(controller, target) {
            if (controller.plateId !== target.plateId) return false;
            if (controller.controls || target.controller) return false;
            let c = controller;
            let depth = 1;
            while (c) {
                if (c === target) return false;
                c = c.controller;
                depth++;
                if (depth > 4) return false;
            }
            return true;
        }

        function setupLocks() {
            for (const plate of activePlates) {
                const all = plate.screws;
                const candidates = all.filter(s => !s.controller && !s.controls);
                for (const locked of candidates) {
                    if (Math.random() > 0.2) continue;
                    const controllers = all.filter(c => c !== locked && canControl(c, locked));
                    if (controllers.length === 0) continue;
                    const controller = controllers[Math.floor(Math.random() * controllers.length)];
                    applyLock(controller, locked);
                }
            }
            updateDotBlockStates();
        }

        function spawnNextPlate() {
            while (nextPlateIndex < plates.length && activePlates.length < MAX_VISIBLE_PLATES) {
                const next = plates[nextPlateIndex++];
                if (spawnPlate(next)) {
                    setupLocks();
                    break;
                }
            }
        }

        function checkPlateRemoval(cell) {
            setTimeout(() => {
                const pid = cell.dataset.plateId;
                console.log('checkPlateRemoval:', pid);
                if (!pid) return;
                const plate = activePlates.find(p => p.id == pid);
                console.log('plate:', plate);
                if (!plate) return;
                const hasDot = plate.screws.some(s => s.cell && s.cell.querySelector('.dot') && s.dot);
                console.log('hasDot:', hasDot);
                if (!hasDot) {
                    removePlate(plate);
                    spawnNextPlate();
                } else {
                    console.log('hasDot:', plate.screws.find(s => s.cell && s.cell.querySelector('.dot') && s
                        .dot));
                }
            }, 10);
        }

        function setupBox(box) {
            // clear previous filled dots and count them as eliminated
            [...box.children].forEach(child => {
                if (child.dataset.filled) {
                    colorOnField[child.dataset.color]--;
                    eliminated++;
                }
            });

            const tempCounts = Object.fromEntries(COLORS.map(c => [c, 0]));
            tempSlots.forEach(t => {
                if (t.children.length > 0) {
                    const c = t.children[0].dataset.color;
                    tempCounts[c]++;
                }
            });

            const candidateColors = COLORS.filter(c =>
                boxPool[c] > 0 &&
                (colorPool[c] > 0 || colorOnField[c] > 0 || tempCounts[c] > 0)
            );
            let availableColors = candidateColors.filter(c => !usedBoxColors.has(c));
            if (availableColors.length === 0) {
                availableColors = candidateColors;
            }

            if (availableColors.length === 0) {
                box.dataset.enabled = "false";
                box.classList.remove("enabled");
                box.style.borderColor = "#ccc";
                box.innerHTML = "";
                return;
            }

            const color = availableColors[Math.floor(Math.random() * availableColors.length)];
            boxPool[color]--;

            box.dataset.color = color;
            box.dataset.enabled = "true";
            box.classList.add("enabled");
            box.style.borderColor = color;
            box.innerHTML = "";
            usedBoxColors.add(color);

            for (let i = 0; i < 3; i++) {
                const slot = document.createElement("div");
                slot.className = "slot";
                box.appendChild(slot);
            }

            absorbTempDots(color, box);
            updateInfo();
        }

        function absorbTempDots(color, box) {
            const matchingDots = [];
            tempSlots.forEach(temp => {
                if (temp.children.length > 0) {
                    const tempDot = temp.children[0];
                    if (tempDot.dataset.color === color) {
                        matchingDots.push(tempDot);
                    }
                }
            });

            if (matchingDots.length >= 3) {
                for (let i = 0; i < 3; i++) {
                    removeDot(matchingDots[i]);
                }
                setTimeout(() => {
                    usedBoxColors.delete(color);
                    setupBox(box);
                    showMessage("ğŸ‰ è‡ªåŠ¨ä¸‰æ¶ˆï¼");
                    setTimeout(() => showMessage(""), 1500);
                    updateInfo();
                    checkVictory();
                }, 300);
            } else {
                for (let dot of matchingDots) {
                    const emptySlot = [...box.children].find(s => s.className === "slot" && !s.dataset.filled);
                    if (emptySlot) {
                        const newDot = document.createElement("div");
                        newDot.className = "slot";
                        newDot.style.backgroundColor = color;
                        newDot.dataset.color = color;
                        newDot.dataset.filled = "true";
                        emptySlot.replaceWith(newDot);
                        dot.remove();
                    }
                }
                updateInfo();
                checkVictory();
            }
        }



        function totalRemainingPool() {
            return COLORS.reduce((s, c) => s + colorPool[c], 0);
        }


        function handleDotClick(dot) {
            if (dot.dataset.blocked === "true") return;
            const color = dot.dataset.color;
            for (const box of boxes) {
                if (box.dataset.enabled !== "true") continue;
                if (box.dataset.color !== color) continue;

                const emptySlot = [...box.children].find(el => el.className === "slot" && !el.dataset.filled);
                if (emptySlot) {
                    const fromCell = dot.parentElement;
                    const screw = screwMap[dot.dataset.sid];
                    if (screw) screw.dot = null;
                    lockConnections.slice().forEach(conn => {
                        if (conn.controller === screw || conn.locked === screw) removeConnection(conn);
                    });
                    const newDot = document.createElement("div");
                    newDot.className = "slot";
                    newDot.style.backgroundColor = color;
                    newDot.dataset.color = color;
                    newDot.dataset.filled = "true";
                    emptySlot.replaceWith(newDot);
                    dot.remove();
                    checkPlateRemoval(fromCell);
                    // è®°å½•æœ¬æ¬¡æ‹”å‡ºçš„æ ¼å­ï¼Œä¾›ç”Ÿæˆç®—æ³•ä½¿ç”¨
                    lastRemovedCell = fromCell;
                    updateInfo();
                    checkVictory();

                    const filled = [...box.children].filter(s => s.dataset.color === color).length;
                    if (filled === 3) {
                        setTimeout(() => {
                            usedBoxColors.delete(box.dataset.color);
                            setupBox(box);
                            showMessage("ğŸ‰ ä¸‰æ¶ˆæˆåŠŸï¼");
                            setTimeout(() => showMessage(""), 1500);
                            updateInfo();
                            checkVictory();
                        }, 300);
                    }
                    return;
                }
            }

            for (const temp of tempSlots) {
                if (temp.children.length === 0) {
                    const fromCell = dot.parentElement;
                    const screw = screwMap[dot.dataset.sid];
                    if (screw) screw.dot = null;
                    lockConnections.slice().forEach(conn => {
                        if (conn.controller === screw || conn.locked === screw) removeConnection(conn);
                    });
                    temp.appendChild(dot);
                    dot.style.position = "absolute";
                    // è®°å½•æœ¬æ¬¡æ‹”å‡ºçš„æ ¼å­ï¼Œä¾›ç”Ÿæˆç®—æ³•ä½¿ç”¨
                    lastRemovedCell = fromCell;
                    checkPlateRemoval(fromCell);
                    updateInfo();
                    checkVictory();
                    return;
                }
            }

            showMessage("ğŸ’¥ æ¸¸æˆå¤±è´¥ï¼ä¸´æ—¶æ§½å·²æ»¡ï¼");
            disableGame();
        }

        function initBoxes() {
            usedBoxColors.clear();
            boxes.forEach((box, i) => {
                box.innerHTML = "";
                if (box.dataset.enabled === "true") {
                    setupBox(box);
                } else {
                    const hint = document.createElement("div");
                    hint.className = "hint";
                    hint.textContent = "ç‚¹å‡»å¼€å¯";
                    box.appendChild(hint);
                    box.style.borderColor = "#ccc";
                    box.addEventListener("click", () => {
                        setupBox(box);
                        box.querySelector(".hint") && box.querySelector(".hint").remove();
                    });
                }
            });
        }

        function showMessage(msg) {
            message.textContent = msg;
        }

        function updateInfo() {
            totalCountEl.textContent = TOTAL_SCREWS;
            eliminatedCountEl.textContent = eliminated;
            const queue = totalRemainingPool();
            const onBoard = document.querySelectorAll("#game-board .dot").length;
            const boxDots = [...boxes].reduce((s, b) => s + [...b.children].filter(el => el.dataset.filled).length, 0);
            const tempDots = [...tempSlots].reduce((s, t) => s + t.children.length, 0);
            const remaining = queue + boxDots + tempDots + onBoard;
            remainingCountEl.textContent = remaining;
            onboardCountEl.textContent = onBoard;
            queueCountEl.textContent = queue;
            const dots = document.querySelectorAll("#game-board .dot");
            const colors = new Set();
            dots.forEach(d => colors.add(d.dataset.color));
            colorCountEl.textContent = colors.size;
            colorStats.innerHTML = COLORS.map(c => {
                const screws = colorPool[c] + colorOnField[c];
                const boxesCreated = COLOR_BOX_TOTALS[c] - boxPool[c];
                return `<div style="color:${c}">${COLOR_NAMES[c]}èºä¸:<span>${screws}</span>/${COLOR_TOTALS[c]} ç›’å­:<span>${boxesCreated}</span>/${COLOR_BOX_TOTALS[c]}</div>`;
            }).join("");
        }

        function disableGame() {
            document.querySelectorAll('.dot').forEach(d => d.style.pointerEvents = 'none');
            boxes.forEach(b => b.style.pointerEvents = 'none');
        }

        function checkVictory() {
            const boardDots = document.querySelectorAll('#game-board .dot').length;
            const boxDots = [...boxes].reduce((s, b) => s + [...b.children].filter(el => el.dataset.filled).length, 0);
            const tempDots = [...tempSlots].reduce((s, t) => s + t.children.length, 0);
            if (boardDots === 0 && boxDots === 0 && tempDots === 0 && totalRemainingPool() === 0) {
                showMessage('ğŸ† æ¸¸æˆèƒœåˆ©ï¼');
                disableGame();
            }
        }

        createGrid();
        activateCells();
        generatePlates();
        for (let i = 0; i < MAX_VISIBLE_PLATES; i++) {
            spawnNextPlate();
        }
        initBoxes();
        setupLocks();
    </script>
</body>

</html>